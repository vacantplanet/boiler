{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Boiler Template Engine for PHP Boiler is a native >=PHP 8.2 template engine, which it is heavily inspired by Plates . Like Plates , Boiler does not introduce a new template language and instead uses PHP itself. You simply use the PHP statements you already know. The main differences to Plates are: Boiler automatically escapes strings and Stringable values. This is optional. You can turn it off globally or for single render calls. The template context is global by default. That means all values available in the main template are available in all included parts, like sections , inserts or layouts . Features Autoescaping: Prevents XSS attacs from untrusted user input by passing all rendererd strings to PHP's htmlspecialchars function. A simple API. Only one class, the Engine , is usually needed. Code reuse with template inheritance and inclusion . You use plain PHP in your templates. No need to learn another syntax. Fully tested and statically analyzed with Psalm set to level 1. Reasonable performance. Next: Quick Start or The Engine .","title":"Introduction"},{"location":"#boiler-template-engine-for-php","text":"Boiler is a native >=PHP 8.2 template engine, which it is heavily inspired by Plates . Like Plates , Boiler does not introduce a new template language and instead uses PHP itself. You simply use the PHP statements you already know. The main differences to Plates are: Boiler automatically escapes strings and Stringable values. This is optional. You can turn it off globally or for single render calls. The template context is global by default. That means all values available in the main template are available in all included parts, like sections , inserts or layouts .","title":"Boiler Template Engine for PHP"},{"location":"#features","text":"Autoescaping: Prevents XSS attacs from untrusted user input by passing all rendererd strings to PHP's htmlspecialchars function. A simple API. Only one class, the Engine , is usually needed. Code reuse with template inheritance and inclusion . You use plain PHP in your templates. No need to learn another syntax. Fully tested and statically analyzed with Psalm set to level 1. Reasonable performance. Next: Quick Start or The Engine .","title":"Features"},{"location":"engine/","text":"The Engine The Engine is the Boiler's central object and usually the only one you have to manually instatiate. It is used to locate and load templates from the file system. Throughout this page we assume the following directory structure: path `-- to |-- templates `-- additional Creating the Engine instance To create an Engine instance, you simply pass one or more paths to directories where your templates are located. Additionally, you can optionally set default values that are available for all your templates, or you can globally disable the autoescaping feature. Using a single template directory The only required parameter of the constructor is the path to a directory where your templates reside: $engine = new \\VacantPlanet\\Boiler\\Engine('/path/to/templates'); If the directory does not exists, Boiler throws a \\VacantPlanet\\Boiler\\Exception\\DirectoryNotFound exception. Using multiple directories If you have multiple directories, pass them in an array: $engine = new \\VacantPlanet\\Boiler\\Engine(['/path/to/templates', '/path/to/additional']); Note : The directories are searched in order. Using the example above: If a template cannot be located in /path/to/additional , Boiler tries to find it in /path/to/additional and so on. Using namespaces You can use namespaces to later be able to address a specific directory. Pass the list of directories as associative array where the keys serve as namespaces: $engine = new \\VacantPlanet\\Boiler\\Engine([ 'first' => '/path/to/templates', 'second' => '/path/to/additional' ]); Check Rendering Templates to see it in action. Adding default values You can assign default values which are available in all templates: $engine = new \\VacantPlanet\\Boiler\\Engine('/path/to/dir', ['value' => 'default value']); Turning off autoescaping If you don't want to use the autoescaping feature, e. g. to improve the performance of your application, you can turn it off globally: $engine = new \\VacantPlanet\\Boiler\\Engine('/path/to/dir', [], false); // better: $engine = new \\VacantPlanet\\Boiler\\Engine('/path/to/dir', autoescape: false); Rendering Templates You simplic call the render method and pass the name/path of the template and optionally an array of values (the context) which will be available as variables in the template. $engine->render('template'); // with context $engine->render('template', ['value1' => 1, 'value2' => 2]); See Rendering Templates for more information. Adding custom template methods Custom methods can be accessed in templates using $this (See Rendering Templates ). To a add a method you pass a Closure or anonymous function to registerMethod : $engine->registerMethod('upper', function (string $value): string { return strtoupper($value); }); Other useful Engine methods Check if a template exists To check if a template exists before rendering it, use the method exists : if ($engine->exists('template')) { $engine->render('template'); } Get the file system path of a template $filePath = $engine->getFile('template'); Get a template instance without rendering it $template = $engine->template('template'); assert($template instanceof \\VacantPlanet\\Boiler\\Template);","title":"The Engine"},{"location":"engine/#the-engine","text":"The Engine is the Boiler's central object and usually the only one you have to manually instatiate. It is used to locate and load templates from the file system. Throughout this page we assume the following directory structure: path `-- to |-- templates `-- additional","title":"The Engine"},{"location":"engine/#creating-the-engine-instance","text":"To create an Engine instance, you simply pass one or more paths to directories where your templates are located. Additionally, you can optionally set default values that are available for all your templates, or you can globally disable the autoescaping feature.","title":"Creating the Engine instance"},{"location":"engine/#using-a-single-template-directory","text":"The only required parameter of the constructor is the path to a directory where your templates reside: $engine = new \\VacantPlanet\\Boiler\\Engine('/path/to/templates'); If the directory does not exists, Boiler throws a \\VacantPlanet\\Boiler\\Exception\\DirectoryNotFound exception.","title":"Using a single template directory"},{"location":"engine/#using-multiple-directories","text":"If you have multiple directories, pass them in an array: $engine = new \\VacantPlanet\\Boiler\\Engine(['/path/to/templates', '/path/to/additional']); Note : The directories are searched in order. Using the example above: If a template cannot be located in /path/to/additional , Boiler tries to find it in /path/to/additional and so on.","title":"Using multiple directories"},{"location":"engine/#using-namespaces","text":"You can use namespaces to later be able to address a specific directory. Pass the list of directories as associative array where the keys serve as namespaces: $engine = new \\VacantPlanet\\Boiler\\Engine([ 'first' => '/path/to/templates', 'second' => '/path/to/additional' ]); Check Rendering Templates to see it in action.","title":"Using namespaces"},{"location":"engine/#adding-default-values","text":"You can assign default values which are available in all templates: $engine = new \\VacantPlanet\\Boiler\\Engine('/path/to/dir', ['value' => 'default value']);","title":"Adding default values"},{"location":"engine/#turning-off-autoescaping","text":"If you don't want to use the autoescaping feature, e. g. to improve the performance of your application, you can turn it off globally: $engine = new \\VacantPlanet\\Boiler\\Engine('/path/to/dir', [], false); // better: $engine = new \\VacantPlanet\\Boiler\\Engine('/path/to/dir', autoescape: false);","title":"Turning off autoescaping"},{"location":"engine/#rendering-templates","text":"You simplic call the render method and pass the name/path of the template and optionally an array of values (the context) which will be available as variables in the template. $engine->render('template'); // with context $engine->render('template', ['value1' => 1, 'value2' => 2]); See Rendering Templates for more information.","title":"Rendering Templates"},{"location":"engine/#adding-custom-template-methods","text":"Custom methods can be accessed in templates using $this (See Rendering Templates ). To a add a method you pass a Closure or anonymous function to registerMethod : $engine->registerMethod('upper', function (string $value): string { return strtoupper($value); });","title":"Adding custom template methods"},{"location":"engine/#other-useful-engine-methods","text":"","title":"Other useful Engine methods"},{"location":"engine/#check-if-a-template-exists","text":"To check if a template exists before rendering it, use the method exists : if ($engine->exists('template')) { $engine->render('template'); }","title":"Check if a template exists"},{"location":"engine/#get-the-file-system-path-of-a-template","text":"$filePath = $engine->getFile('template');","title":"Get the file system path of a template"},{"location":"engine/#get-a-template-instance-without-rendering-it","text":"$template = $engine->template('template'); assert($template instanceof \\VacantPlanet\\Boiler\\Template);","title":"Get a template instance without rendering it"},{"location":"inserts/","text":"Inserts","title":"Inserts"},{"location":"inserts/#inserts","text":"","title":"Inserts"},{"location":"layouts/","text":"Layouts","title":"Layouts"},{"location":"layouts/#layouts","text":"","title":"Layouts"},{"location":"quickstart/","text":"Quick Start Install Boiler via Composer: composer require vacantplanet/boiler Then create a directory where your PHP templates reside. Assuming the following directory structure ... path `-- to `-- templates ... create the file /path/to/templates/page.php with the content: <p>ID <?= $id ?></p> Now create a Engine instance and render the template: use VacantPlanet\\Boiler\\Engine; $engine = new Engine('/path/to/templates'); $html = $engine->render('page', ['id' => 13]); assert($html == '<p>ID 13</p>');","title":"Quick Start"},{"location":"quickstart/#quick-start","text":"Install Boiler via Composer: composer require vacantplanet/boiler Then create a directory where your PHP templates reside. Assuming the following directory structure ... path `-- to `-- templates ... create the file /path/to/templates/page.php with the content: <p>ID <?= $id ?></p> Now create a Engine instance and render the template: use VacantPlanet\\Boiler\\Engine; $engine = new Engine('/path/to/templates'); $html = $engine->render('page', ['id' => 13]); assert($html == '<p>ID 13</p>');","title":"Quick Start"},{"location":"rendering/","text":"Rendering Templates After you created an \\VacantPlanet\\Boiler\\Engine object, you can render templates using its render() method. Throughout this page we assume the following directory structure ... path `-- to |-- templates | |-- subdir | | `-- subtemplate.php | |-- blog.php | |-- layout.php | |-- more.php | `-- page.php | `-- theme |-- blog.php `-- additional.php ... and the Engine initialized in this way: $engine = new \\VacantPlanet\\Boiler\\Engine( [ 'theme' => '/path/to/theme', 'templates' => '/path/to/templates', ], defaults: [ 'titleSuffix' => ' - Boiler Template Engine', ], autoescape: true, ); Simple rendering To render the template page.php from the filesystem tree above, you reference it using the name page with or without the file extension. $html = $engine->render('page'); // or $html = $engine->render('page.php'); If you like to use a custom file extension add it to the name: $engine->render('page.tpl'); Values available to the template must be provided as associative array: $html = $engine->render('page', [ 'title' => 'The Title', 'content' => 'The content of the page.', ]); If the page.php template would look like this: <body> <h1><?= $title ?></h1> <div><?= $content ?></div> </body> The result of the render call above would be: <body> <h1>The Title</h1> <div>The content of the page.</div> </body> Templates in subdirectories $html = $engine->render('subdir/subtemplate', ['value' => 13]); Template overrides If a template with the same name is available in more than one of your template directories, the first one found is used. In our example above, there is a blog template in both templates and theme . As theme is the first entry in the array passed to Engine , blog from this directory is used by default: // renders /path/to/theme/blog.php $engine->render('blog', ['value' => 13]); This can for example be used to implement themeable or customizable templates where you provide a default set of templates which can later be partially or completely overriden by a theme or similar. You can force to render blog from the templates directory if you use namespaces. See the next section on how this is accomplished. Namespaces In our engine instantiation example above we pass an associative array with the template directories to the constructor. The keys of the array serve as namespaces. To render a template from a specific namespace, locate it using the namespace followed bei a colon followed by the template name: $html = $engine->render('templates:blog', ['value' => 13]); // A template in a subdirectory $html = $engine->render('templates:subdir/subtemplate', ['value' => 13]); This way you can prevent template overriding explained in the section before.","title":"Rendering Templates"},{"location":"rendering/#rendering-templates","text":"After you created an \\VacantPlanet\\Boiler\\Engine object, you can render templates using its render() method. Throughout this page we assume the following directory structure ... path `-- to |-- templates | |-- subdir | | `-- subtemplate.php | |-- blog.php | |-- layout.php | |-- more.php | `-- page.php | `-- theme |-- blog.php `-- additional.php ... and the Engine initialized in this way: $engine = new \\VacantPlanet\\Boiler\\Engine( [ 'theme' => '/path/to/theme', 'templates' => '/path/to/templates', ], defaults: [ 'titleSuffix' => ' - Boiler Template Engine', ], autoescape: true, );","title":"Rendering Templates"},{"location":"rendering/#simple-rendering","text":"To render the template page.php from the filesystem tree above, you reference it using the name page with or without the file extension. $html = $engine->render('page'); // or $html = $engine->render('page.php'); If you like to use a custom file extension add it to the name: $engine->render('page.tpl'); Values available to the template must be provided as associative array: $html = $engine->render('page', [ 'title' => 'The Title', 'content' => 'The content of the page.', ]); If the page.php template would look like this: <body> <h1><?= $title ?></h1> <div><?= $content ?></div> </body> The result of the render call above would be: <body> <h1>The Title</h1> <div>The content of the page.</div> </body>","title":"Simple rendering"},{"location":"rendering/#templates-in-subdirectories","text":"$html = $engine->render('subdir/subtemplate', ['value' => 13]);","title":"Templates in subdirectories"},{"location":"rendering/#template-overrides","text":"If a template with the same name is available in more than one of your template directories, the first one found is used. In our example above, there is a blog template in both templates and theme . As theme is the first entry in the array passed to Engine , blog from this directory is used by default: // renders /path/to/theme/blog.php $engine->render('blog', ['value' => 13]); This can for example be used to implement themeable or customizable templates where you provide a default set of templates which can later be partially or completely overriden by a theme or similar. You can force to render blog from the templates directory if you use namespaces. See the next section on how this is accomplished.","title":"Template overrides"},{"location":"rendering/#namespaces","text":"In our engine instantiation example above we pass an associative array with the template directories to the constructor. The keys of the array serve as namespaces. To render a template from a specific namespace, locate it using the namespace followed bei a colon followed by the template name: $html = $engine->render('templates:blog', ['value' => 13]); // A template in a subdirectory $html = $engine->render('templates:subdir/subtemplate', ['value' => 13]); This way you can prevent template overriding explained in the section before.","title":"Namespaces"},{"location":"sections/","text":"Sections","title":"Sections"},{"location":"sections/#sections","text":"","title":"Sections"},{"location":"template/","text":"Template Creates a Engine object on the fly and sets the root directory to the dir where the passed template resides.","title":"Template"},{"location":"template/#template","text":"Creates a Engine object on the fly and sets the root directory to the dir where the passed template resides.","title":"Template"},{"location":"values/","text":"Displaying Values If you pass a value of type VacantPlanet\\Boiler\\Value to e / escape it will automatically be unwrapped before it is passed to htmlspecialchars . Changing the arguments passed to htmlspecialchars Wrapped values pass the flags ENT_QUOTES | ENT_SUBSTITUTE and the encoding UTF-8 when calling PHP's htmlspecialchars function internally. If you need to override these defaults use the template helper method e or its long form escape : $this->e($value, ENT_NOQUOTES | ENT_HTML401, 'EUC-JP'); $this->e( value: $value, flags: ENT_NOQUOTES | ENT_HTML401, encoding: 'EUC-JP' ); // or $this->escape($value, ENT_NOQUOTES | ENT_HTML401, 'EUC-JP');","title":"Displaying Values"},{"location":"values/#displaying-values","text":"If you pass a value of type VacantPlanet\\Boiler\\Value to e / escape it will automatically be unwrapped before it is passed to htmlspecialchars .","title":"Displaying Values"},{"location":"values/#changing-the-arguments-passed-to-htmlspecialchars","text":"Wrapped values pass the flags ENT_QUOTES | ENT_SUBSTITUTE and the encoding UTF-8 when calling PHP's htmlspecialchars function internally. If you need to override these defaults use the template helper method e or its long form escape : $this->e($value, ENT_NOQUOTES | ENT_HTML401, 'EUC-JP'); $this->e( value: $value, flags: ENT_NOQUOTES | ENT_HTML401, encoding: 'EUC-JP' ); // or $this->escape($value, ENT_NOQUOTES | ENT_HTML401, 'EUC-JP');","title":"Changing the arguments passed to htmlspecialchars"}]}